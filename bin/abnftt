#!/usr/bin/env ruby -Ku

require 'pp'
require 'yaml'

Encoding.default_external = Encoding::UTF_8

require 'abnftt'

def to_treetop(ast, ofn)
  modname = File.basename(ofn).sub("-", "_").sub(/[^_a-zA-Z]/, "").upcase
  <<~EOS
    # Encoding: UTF-8
    grammar #{modname}
    #{ast.map {|x| to_treetop0(x)}.join}
    end
  EOS
end
def to_treetop0(ast)
  fail ast.inspect unless ast[0] == "="
  <<~EOS
    rule #{to_treetop1(ast[1])}
    #{to_treetop1(ast[2])}
    end
  EOS
end
FIXUP_NAMES = Hash.new {|h, k| k}
FIXUP_NAMES.merge!({
                     "rule" => "r__rule",
                   })
def to_treetop1(ast)
  case ast
  when String
    FIXUP_NAMES[ast].gsub("-", "_")
  when Array
    case ast[0]
    when "alt" # ["alt", *a]
      "(#{ast[1..-1].map {|x| to_treetop1(x)}.join(" / ")})"
    when "seq" # ["seq", *a]
      "(#{ast[1..-1].map {|x| to_treetop1(x)}.join(" ")})"
    when "rep" # ["rep", s, e, a]
      t = to_treetop1(ast[3]) || "@@@"
      case [ast[1], ast[2]]
      when [0, 1]
        t + "?"
      when [0, true]
        t + "*"
      when [1, true]
        t + "+"
      else
        t + " #{ast[1]}..#{ast[2] == true ? '' : ast[2]}"
      end
    when "prose" # ["prose", text]
      fail "prose not implemented #{ast.inspect}"
    when "ci" # ["ci", text]
      s = ast[1]
      if s =~ /\A[^A-Za-z]*\z/
        s.inspect
      else
        s.inspect << "i"        # could do this always, but reduce noise
      end
    when "cs" # ["cs", text]
      ast[1].inspect
    when "char-range" # ["char-range", c1, c2]
      c1 = Regexp.quote(ast[1])
      c2 = Regexp.quote(ast[2])
      "[#{c1}-#{c2}]"           # XXX does that always work
    when "im" # ["im", a, text]
      to_treetop1(ast[1]) + " " + ast[2]
    else
      fail "to_treetop(#{ast.inspect})"
    end
  else
    fail "to_treetop(#{ast.inspect})"
  end
end

unless fn = ARGV[0]
  warn "Usage: abnftt grammar.abnftt"
  exit 1
end
outfn = fn.sub(/\.abnftt\z/, "")

parser = ABNFParser.new
abnf_file = File.read(fn)
ast = parser.parse abnf_file
if ast
#  p ast
  File.open("#{outfn}.yaml", "w") do |f|
    f.puts ast.ast.to_yaml
  end
  # pp ast.ast
  File.open("#{outfn}.treetop", "w") do |f|
    f.puts to_treetop(ast.ast, outfn)
  end
  File.open("#{outfn}.abnf", "w") do |f|
    f.puts ast.clean_abnf.lines.map(&:rstrip).join("\n")
  end
else

  puts parser.failure_reason
  parser.failure_reason =~ /^(Expected .+) after/m
  puts "#{$1.gsub("\n", '<<<NEWLINE>>>')}:"
  puts abnf_file.lines.to_a[parser.failure_line - 1]
  puts "#{'~' * (parser.failure_column - 1)}^"
end
